#Redis
##内存:
#####在redis中内存管理是非常重要的,通过redis.conf中的maxmemory可以调整redis可用的最大内存。
###windows：
#####64bit 默认maxmemory 0 是无内存限制
#####32bit 默认maxmemory 0 是3GB大小

###如果达到最大内存会发生什么?
#####redis默认情况下会返回异常信息，这是redis的默认`内存淘汰策略`;
###还有其他可选择的内存淘汰策略吗?
redis的内存淘汰策略在4.0之前主要是近似LRU(最近最久未使用算法)算法,
4.0增加了近似LFU(最近最少使用)算法;
####拒绝策略有以下几种:
######1.noeviction 
当达到内存限制并且客户端尝试执行可能导致使用更多内存的命令时，将返回错误（大多数写入命令，但DEL和一些其他例外）。
######2.allkeys-lru
通过尝试删除最近最久未使用的key。
######3.volatile-lru
通过尝试删除设置了过期时间中最近最久未使用的key。
######4.allkeys-random
随机删除key
######5.volatile-random
随机删除设置过期时间的key
######6.volatile-ttl
驱逐出设置过期时间且短生存时间(ttl)的key
######7.volatile-lfu
驱逐出设置过期时间中最近最少使用的key
######8.allkeys-lfu
驱逐出最近最少使用的key

####策略如何选择呢?
######1.如果不确定自身项目的key使用情况,allkeys-lru是比较好的选择
######2.如果你希望所有元素的访问都是分布统一的请使用allkeys-random
######3.你的项目中缓存对象设置了不同ttl时间,请使用volatile-ttl

####内存淘汰策略是如何工作的呢?
客户端运行添加命令,redis检查内存使用情况,如果大于最大内存执行策略,反之会添加数据

####为什么使用近似LRU?
因为一个确切的LRU算法太消耗内存了,近似LRU算法通过检查一小块key样本,从中选取最近最久未使用的key删除。
在3.0版本还对LRU算法进行了优化,最棒的是增加了用户自身通过调整样本的大小来调整LRU的精度。
用户可以通过maxmemory-samples参数来调整检查样本的大小 
![Image text](lru_comparison.png)
可以看到样本数在10个时已经很接近确切的LRU算法了

####新增加的LFU算法怎么样?
LFU其实近似于LRU
#####LFU通过在key上维护一个几位bits的计数器(Morris counter),该计数器范围(0-255),每次访问这个key时计数器就增大,计数器越大表示这个key访问越频繁。
#####如果key后续不被访问,计数器会随着时间衰减
#####lfu-decay-time 表示每分钟衰减次数  
#####lfu-log-factor 表示对数因子,key要访问多少次才会达到最大值,数值越大达到饱和的访问次数越大
```
    +--------+------------+------------+------------+------------+------------+
    | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
    +--------+------------+------------+------------+------------+------------+
    | 0      | 104        | 255        | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 1      | 18         | 49         | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 10     | 10         | 18         | 142        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 100    | 8          | 11         | 49         | 143        | 255        |
    +--------+------------+------------+------------+------------+------------+
```
####如果新增的key如果触发淘汰就会很容易被淘汰吗？
#####redis默认给新创建的对象设置了count = 5
redis对象结构
```
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;
```
lru原本是记录LRU time的,但是LFU策略是 高16位记录最近一次访问时间 低8位记录计数器值

